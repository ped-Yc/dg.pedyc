---
title: 5-大前端：如何突破动态化容器的天花板？ - 美团技术团队
uid: 
aliases: []
author: 
description: 
tags: []
date-created: 2025-02-12
date-modified: 2025-02-14
status: 
banner: "https://images.unsplash.com/photo-1569377863462-aff9b3a63b3c?crop=entropy&cs=srgb&fm=jpg&ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHx8fDE3MzkzNDE3OTd8&ixlib=rb-4.0.3&q=85&fit=crop&w=880&max-h=540"
banner_icon: 🔖
url: https://tech.meituan.com/2024/10/18/recce-in-meituan.html
---

本文整理自美团技术沙龙第 83 期《前端新动向》（[B 站视频](https://www.bilibili.com/video/BV1aGHMeWEAx/?spm_id_from=333.788&vd_source=aea2a93491bea0d72f7e5b8a79085d70)）。长久以来，容器要实现动态化和双端复用，难免要牺牲掉一些性能。有没有办法让动态化容器的性能尽可能接近原生？美团金服大前端团队给出了一种解决方案，尝试突破动态化容器的天花板。

## 1 动态化容器的天花板

自 2015 年 [React Native](https://en.wikipedia.org/wiki/React_Native) 推出至今 9 年时间，各类容器（动态化容器简称，下同）方案已经成为业界前端的普遍选择。业界有微信（小程序）、抖音（Lynx）、拼多多（Lego）、支付宝（Nebula/BirdNest）、京东（Taro-Native）等。美团也有 MRN、MMP/MSC 等容器。可以说容器是前端工程的关键基石，也是绕不开的话题。

过去我们做动态化改造主要为了解决以下问题：

1. **降研发成本**：通过容器将多端合一，避免一个需求在每个端重复开发，以改善研发成本结构。随着 HarmonyOS NEXT 的推广，这个优势将变得更大。
2. **增部署效率**：通过动态发布避开 App 集中集成，使得业务在移动端上可以独立部署和发布、实现 211 迭代，提升业务迭代面客效率。

然而凡事有利必有弊，有用必有费。动态化容器在解决上述问题的同时也带来以下问题：

1. **降低页面成功**：动态化容器引入了动态部署、解释器等更多的环节。在增加整体复杂度的同时，更多的环节也带来了更多的错误和计算开销，具体体现在页面白屏和页面加载耗时增加上。
2. **牺牲用户体验**：动态化容器需要更多的硬件算力，相同的业务复杂度下，容器化页面相较原生页面更慢、更卡、不流畅，这在下沉市场设备上更为突出，卡顿甚至成为卡死。

![](https://p0.meituan.net/meituantechblog/31ce13d9379f94f5b526304dbd1cd8321161128.png)

动态化容器的绝对天花板是原生应用，目前事实天花板是 React Native/WebView。

定性地看前端容器天花板的问题，这里引述我们美团容器界的一位前辈的理论：性能、效能、动态化是动态化容器的不可能三角（下图左）。现有的通用的容器方案都是在这三个维度做 " 三选二 "。

定量地看动态化容器，下图（右）展示了一个 3000 个相同视图节点的简单 Benchmark 页面。没有额外逻辑，也没有网络请求，以 React Native 为例，在同一台设备上，在 React Native 上做一个这个页面，动态化页面加载耗时大约是 Native 原生页面的 5 倍。

![](https://p0.meituan.net/meituantechblog/c78d912d6c995a650360de344a6f3403376928.png)

这个测试结果不一定容易接受，但是很好理解。在相同的业务复杂度下，**动态化容器为了实现动态化，引入了一个逻辑解释器，增加了解释执行和与解释器通信的额外计算开销，这就是动态化页面性能表现差的主要原因**。既享受动态化的好处，又不牺牲用户性能体验，只在现有的方案上做选择是不可能达到的。不过金服大前端团队在这个问题上却是取得了一些实质性进展。

![](https://p0.meituan.net/meituantechblog/27566a3ecfe765f10c137b61ec370872419105.png)

先说一下我们目前取得的成果：美团金服前端团队做了一个新的容器 Recce，然后在同样的测试页中，我们将执行业务逻辑部分的速度提升了 8 倍，整体的页面加载速度提升了一倍。而在实际的业务中，页面加载速度也实现了 3 倍的提升，在兼顾动态化和效能的前提下，实现了性能的大跨步提升，性能表现接近 Native 原生。下文将重点介绍 Recce 具体是怎么实现的，希望能够给大家提供一些帮助或借鉴。

## 2 容器分类及前期思考

首先，当我们计划做一个容器之前，需要先对现有容器建立基本的认识。

前端容器最重要部分之一在于绘制图形界面以完成人机交互，现有主要容器方案按照绘制方式可归纳为下列三类：

* 第一类可以称为基于 Web 的方案，这类的共同特点就是调用 WebView， 通过 JavaScript 和 CSS 去绘制页面，然后通过 Web 提供的接口去和宿主通信。
* 第二类称之为 " 自己绘制 "，它会调用更底层的 OpenGL 等图形的绘制框架，同时也会有自己的一套方案和语言去标记和编写自己的这些页面。
* 第三类则是去调用系统的 UI 框架，就是基于平台提供的 UI 框架去进行绘制，和第二种的区别是，会有一层抹平平台差异的平台抽象层。

![](https://p0.meituan.net/meituantechblog/4610a8a9b595653007fb28b58935f9b3739915.png)

对现有的容器再做进一步的结构分解，方便我们对不同容器方案之间做对比，这里拆分为四层：

* 第一层，也就是最上层的 UI 框架，跟我们直接平时写的代码相关，它会直接决定业务代码的样子。
* 第二层，其作用就像它的名字一样，也就是运行时支持，为运行 UI 框架提供支持，在这里会有解释器或者是标准库之类的东西。
* 第三层，会对不同平台去做一层不同的抽象，比如像 RN 会对视图操作之类的统一为相同概念和统一接口。
* 第四层，渲染层，对应着不同分类选择的各自的渲染的方式。

![](https://p0.meituan.net/meituantechblog/28a59254e5736fc6934f6517e6e365b6561990.png)

那么下面，我们就会基于上图对现有容器这个分类和结构为认知基础，结合之前影响容器性能表现最大的因素在于逻辑解释器执行效率和逻辑解释器通信效率这个认知，再去考虑实现一个满足性能、安全、动态化的容器方案该怎么做。

![](https://p0.meituan.net/meituantechblog/2a9e19cda235bdac8df3be491bd8d14b539616.png)

## 3 Recce 的选型与搭建

所以如何选择 UI 框架、运行时支持、平台抽象层、渲染层 来实现一个高性能、安全的动态化容器呢。首先把渲染层放到最后，因为渲染层作为最底层并不影响上层选型。然后我们首先讨论运行时支持怎么选，准确的说是解释器和编程语言怎么选，因为编程语言会影响上层 UI 框架，而解释器也影响到平台抽象层中的通信部分，所以接下来的讨论顺序是：**解释器 & 编程语言、UI 框架、渲染层以及整体架构**这四部分。

### 3.1 解释器 & 编程语言的选择

**解释器以 Wasm 为主， JavaScript 为辅**

前文也提到，我们期望能获得一个既能满足性能，又安全，同时还可以动态化这样的一个方案。既然必须动态化，就必须有逻辑解释器 [1]，问题就变成了怎样选一个性能好且安全的解释器，并且成本在可接受范围。现成的解释器还是不少的，前端范畴有 V8、JavaScriptCore、QuickJS 等 JavaScript 解释器，有符合 WebAssembly（后简称 Wasm） 规范的 [Wasmer](https://github.com/wasmerio/wasmer)、WasmEdge[2]；大家日常工作中会接触到的 Ruby、Python；还有游戏行业用的比较多的 Lua、C#[3]。

首先可以排除掉 Ruby 和 Python 这两个语言和解释器，无论是性能还是生态都不如 JavaScript。Lua 和 C# 也可以排除，主要是游戏生态和前端差距太远，晚饭想吃炸鸡，中午才开始孵蛋显然就来不及了。在 JavaScript 解释器和 Wasm 解释器两个大范围里，Wasm 解释器在性能和安全上较 JavaScript 解释器有决定性优势，生态上较 JavaScript 略差，但都在 W3C 标准范围内，一样可以运行在 H5 和小程序里，" 晚饭想吃炸鸡，中午开始杀鸡还是来得及的 "。

所以在解释器的选型上，就确定了 Wasm 解释器为主，JavaScript 为辅的基本策略。而 Wasm 解释器具体选择是 Wasm3，原因有两方面：第一，这是在不支持 JIT[4] 下最快的 Wasm 解释器；第二，对包大小占用非常少。

**编程语言选择**

在确定了 Wasm 解释器之后，编程语言的选择就变成了，在支持 Wasm 的语言里选择性能、安全和成本最优的。理论上可以编译成 WebAssembly 执行的语言非常之多，但真正成熟到可以上生产环境的只有 C、C++、Rust、Go 这四种 [5]。首先可以先排除掉 C，虽然性能好但是不支持高级抽象只适合用在嵌入式等极端场景，不适合用来前端写业务。然后可以排除 C++，性能表现上 C++ 和 Rust 不相上下都好过 Go，但是错误管理和内存安全上输 Rust 一筹，并且 C++ 在前端业务层也是生态基本为零，不像 Rust 在前端生态发展迅猛。最后可以排除 Go，在性能表现上、类型系统设计、错误管理、还有前端生态上都输 Rust 一筹。

![](https://p0.meituan.net/meituantechblog/215534aa6db72814d21292e5b97cb04a974481.png)

综上所述，在运行时我们就选择了 Rust 和 Wasm3，JavaScript 和 QuickJS 后面再进行介绍。

![](https://p0.meituan.net/meituantechblog/cabcedd389b35dd6fdd7552d3f5b1f1a553535.png)

### 3.2 UI 框架

用 JavaScript/QuickJS 的部分可以复用 Vue 或者 React，这些先不提。用 Rust 则必须要为运行时的上层设计一套 UI 框架，确定应该怎么样编写页面。这项工作的挑战在于，它并不像 JavaScript 生态，有多年的积累可供参考或复用，比如经典的 React 和 Vue。当然好处在于也没有历史包袱，所以必须要结合 Rust 语言的特点才能更好地完成这个任务。

![](https://p0.meituan.net/meituantechblog/4811d00725b04927716aaf6d39c5b3cb535974.png)

UI 框架大抵需要做到三点：（1）提供声明式 DSL 方便前端研发描述界面；（2）提供组件封装和状态管理能力完成业务逻辑和用户交互的衔接；（3）性能卓越。其中（1）和（2）在 JavaScript 生态中已经都有实现，（3）则未必，否则也不会有几十种 Web UI 框架并存这种局面。这个问题难在如何用 Rust 这门强类型纯静态语言去实现 JavaScript 弱类型动态语言实现的功能，并且要维持 Rust 零开销抽象的优势。

为了解决这个问题，我们参考了 GitHub 上开源的各种框架。一方面参考了 Dioxus 的 DSL 设计和 UI 封装，另一方面也保持了 Rust-Dominator 观察者模式订阅变更的更新效率，我们将这两个优点合并到一起，就得到了 Recce UI，就其特点，没有 Diff，也没有 VDOM，跟 SolidJS 一样实现真正的订阅，我们也尽可能地去保证可以高效地构建 UI。下图中的表格对应的就是一些 Web 项目下的性能对比，这个也并没有直接对应到具体实践的容器上，因为我们也做了一个类似 Native 渲染的东西，所以这个表格对我们来说具备很好的参考价值，至少可以看到 Dominator 的更新效率还是很不错的。

![](https://p0.meituan.net/meituantechblog/71fa8257c0a9050d98a9e90d5ed11cfb1281472.png)

### 3.3 渲染层

渲染层的选择则相对简单，如前述归纳实现一个渲染层大致三种方式：复用 WebView、自建渲染绘制器、调用系统 UI 框架。

1. **复用 WebView**：如果追求高性能，这条路就不通，复用 WebView 意味着渲染指令 / 视图树 要用低效的方式以 WebView 的 JsCore 为跳板再去驱动 WebCore 做渲染。这和高性能就南辕北辙，还不如纯 H5 性能表现好。
2. **自建渲染绘制器**：这条路技术上是行得通的，但目前走不得：第一，从代码量上看 Chromium 内核有数百万行 C++，考虑到跨平台兼容则过千万行代码，这个规模和复杂度是超过美团 App 本身，即使照着写一遍，没有数十名 C++ 专家投入三五年之功是看不到成效的。第二，当世只有 Google 和 Apple 有这个能力做成 WebView。FireFox 的新浏览器计划半途而废，微软则直接放弃转投 Chromium。
3. **调用系统 UI 框架**：类似 RN 的方式，研发成本上是我们能接受的；渲染样式虽然没有 WebView 的 CSS 全，但是 Flex 足够支撑业务需求了，且保持是 W3C 的严格子集；RN 在性能上的问题主要出在通信层上，这个我们可以解决掉；最后也是最重要的是这个选择不是一个单向门，假如我们获得了驾驭 blink[6] 能力，那么就可以很低的成本平滑切换到 blink 上。

所以渲染层就是复用了 React Native 的 Native 部分，我们决定要站在这个 " 巨人 " 的肩膀上开始行动。毕竟 React Native 已经提供了非常优秀的组件封装，同时它也解决了 Android 和 iOS 在渲染层面的差异，因为这些接口基本上都是在系统 UI 下进行封装的，所以我们有理由相信这些接口本身的性能是良好的。

![](https://p0.meituan.net/meituantechblog/8e010e84bc6fb2242733024d81a15acb551974.png)

然后，剩下的问题就是设置属性、传递属性等成本，它们在实践的过程中，通常会成为页面渲染的一个瓶颈，事实上 React Native 也正在解决这个问题。基于此，我们决定保留下来 React Native 的 UIManager 的增、删、改等概念，以及 Yoga 布局，还有视图组件的封装，我们将这些保留了下来。后面，我们还会再讨论为什么没有使用 React Native 当前的属性转换的方式，这里不再展开讨论。

![](https://p0.meituan.net/meituantechblog/b34d60486c81215f46579cd9d2baf80f811498.png)

### 3.4 整体架构

最终，Recce 的概览如下图所示。这里重点讲下先前没有提及的 Recce Host 平台抽象层，这一层我们主要做了两件事：第一件，属性设置优化（或者叫渲染通信优化）；第二件，平台抽象。

属性设置优化后文会详细介绍，这里只说平台抽象。我们结合 WebIDL 的设计和 LLVM 的架构理解，在平台抽象层上下都实现了标准接口。类似 llvm 的 MIR 使得编译器前端和编译器后端可以独立迭代和接入，平台抽象层的标准接口设计使得只要遵循渲染指令标准的解释器或者渲染器都可以很容易接入。这就是我们很容易把 QuickJS + Vue/React 支持了的原因。Recce-js 可以使线上的大部分以 JavaScript 为主的前端页面获得更好的性能表现。同样 Recce 的鸿蒙适配的成本也非常低，不需要上千或者几千 pd 那么多。最重要的是未来替换性能更好的解释器或者语言或者 UI 框架都是简单可行的。这一层是 Rust 实现的高效、安全且使得容器整体架构易扩展和易维护。

![](https://p0.meituan.net/meituantechblog/ee2be7ad06f96a2d9592d471301cb8a7567149.png)

综上选型和搭建工作基本上已经完成了。接下来，我们再对 Recce 上的一些细节问题进行补充。

前面是讲道理，知已不易行更难。下文的 " 干货 " 可能才是决定成败的关键细节。

## 4 Recce 的一些细节问题

首先，就是上一节讨提到的，为什么没有使用 React Native 的属性转换？因为，我们发现属性转换是 React Native 一个性能瓶颈。其实为了评估这个问题，我们做了一个 3000 个节点的页面。当然，这个页面可能跟我们平时常见的页面长得不一样，但是它的渲染和布局成本和业务实际是比较接近的。

![](https://p0.meituan.net/meituantechblog/6a0428c249cc5251bc23144158ec6d67816089.png)

页面的逻辑我们写得尽可能简单，同时去掉了 React Native 的启动时间，然后我们启用了原生代码，但是调用了 Yoga 的布局计算，就这样写了一个页面去做对比。最终发现，二者的耗时差距非常大，因为我们的布局方式是一样的，调用的 UI 也完全是相同的，基于此，我们基本上就可以认定剩下的 93% 的时间都是为了将设置页面的各种各样的数据从 JavaScript 传递到具体的平台，也就是说属性转换会耗费大量的时间。

这里可以再深挖一下，为什么属性转换会耗费这么多的时间？我们稍微研究了一下这个问题后发现，主要还是因为 React Native 会有多次序列化和反序列化，这是一个类似于字典的东西，而且除了序列化的时间，还需要考虑构建字典本身需要的时间，还有执行字典的一些查找、设置等操作，最终我们还需要频繁地按照字典里面的 Key 值查找，查找到之后，再设置到具体的属性设置，而以上这些操作都会消耗掉不少的时间及内存。

![](https://p0.meituan.net/meituantechblog/cf3a561d3fda985b277f28cbb7b03b3b1213469.png)

事实上，React Native 官方也正在尝试解决这个问题，在官方公布的的一个实验性的新的框架中，React Native 直接将一个 JSObject 转换成了一个 C++ 的静态类型（*Props），然后在对应的各个平台中，直接使用了一个转换后的静态类型。如此以来，实际上就只存一次 JSObject 这样字典就可以，从创建开始到最终设置，始终使用这个静态类型，那么剩下的操作都会变得非常高效了。

![](https://p0.meituan.net/meituantechblog/8d146f4893e0b247a38ec3c4cdadb357755678.png)

同时，我们也会去思考应该怎么去解决属性传递以及查找的问题。这里可以简单看一下，我们常用的几种数据结构，都是基于数组、链表、哈希表、字典等等之类。但实际上，我们在这种场景下可以选择的可能就只有字典和数组，而 React Native 最常用的方式就是基于字典去构建各种各样的属性。但是基于字典这种方式并没有非常好的性能，如果传递的载体还是 JSON 字符串的时候，还需要承担 JSON 本身解析的任务。经过考量之后，我们最终决定采用基于索引的数组来构建一个个的属性值。

![](https://p0.meituan.net/meituantechblog/f70fa1b72a67b298b7bb7f67e8051dba602357.png)

但是采取这种模式的话，维护每个数组属性上的索引将会变得非常的复杂，我们借助一个属性定义生成各端代码维护这个索引，我们在运行前约定好每个属性的索引值，当然，我们会放弃一定的兼容性。其中一个放弃的例子就是，当我们约定好一个属性的索引值之后，之后就不能再修改这个属性的索引值本身，否则就会遇到属性设置可能会发生错乱的问题。

![](https://p0.meituan.net/meituantechblog/42c45a480920b62d7fd5f42d847f04eb701183.png)

类似的，我们也可以把组件注册的标识从字符串修改为索引，由于这个属性和组件不太一样，就无法知道客户端会提供哪些原生的组件，所以至少要在运行时去使用字符串获取一次组件信息。在获取之后，就可以使用获取的这个索引，从而保持一个比较快的匹配效率。

![](https://p0.meituan.net/meituantechblog/d67aa2f896b2bf5c72b08cf1f2b2d335543712.png)

最近，我们还做了一个富文本的标签，这个标签跟前两者相比就变得更不一样了。这里实际上输入的是一段 HTML 的字符串，所以输入的内容非常自由，我们没有办法像前两者一样使用一些静态的计算方式。但即便是富文本，仍然可以有一些已知的内容，比如像文本的样式、字符串等等，这些内容是可以提前知道的。而在这个层面，我们是可以做一些事情的，实际上可以基于所有输入的计算，得到一个完美的哈希函数，然后确保所有的输入不会发生碰撞。进而，在查找 Key 的时候就会变得快很多。

![](https://p0.meituan.net/meituantechblog/e3f5aa4198787c52da9671e6053517d9591820.png)

以上，就是我们在遇到属性传递时解决的各种各样的问题。而接下来，我们还需要解决一个问题——跨语言的调用问题。当然，在讨论这个问题之前，我们先简单地将这些调用划分成了四类：

* 第一类是 C 与 C 之间的调用，其实 C 语言本身并没有什么转换，这里只是把它作为一个最特殊的场景，进行归类处理。
* 第二类是 Rust 去调用 C，这两种语言虽然也是直接在原生上去运行的，但是它们之间会增加了一些调用约定之类的转换。
* 第三类是 Java 和 JavaScript 去调用 C，这就需要借助解释器提供的接口去进行调用，其中也会涉及更多的转换的工作，比如说两个内存空间之间的拷贝。
* 第四类，我们认为它们其实更接近这个 IPC 的调用，比如像通过 WebView 提供的基于字符串传递的接口。

![](https://p0.meituan.net/meituantechblog/860d04e458fd3514e945bd3b2b8dead2524156.png)

在这种场景下，我们会有更多的转换工作以及一些编码约定的设置，所以我们必须要找到一种基于字符串编码方式去传递各种复杂的数据。而具体应用到 Recce 内部的时候，其实并不存在类似于 IPC 场景的调用，所以只需要解决每一层之间语言的调用。但实际上，我们仍然面对着非常复杂的调用这个事实。

参考下图，可以看到每一层实际上都涉及到一个具体的跨语言调用。同时，还有刚刚提到的性属性设置，它则会跨过中间的所有层级，直接设置到具体的平台。最后要需要强调一下，涉及到具体的属性以及类似的一些方法调用，比如说打开相机，也会跨过中间层直接去做调用，而这个调用跟属性设置又存在很多不一样的地方。

![](https://p0.meituan.net/meituantechblog/d67bd95a83ba992daa0683e1d0ab6543498989.png)

针对不同的调用场景，我们也采取了两种不同的解决方案：

* **手写 + 辅助函数**：通常用在不会频繁增改接口、手写本身已经比较好维护。
* **接口定义 + 代码生成**：可能频繁增改接口、手写维护会非常困难（还需要频繁维护文档）。

具体来讲，我们分成了以下 4 个场景：

1. **属性设置**：把定义的属性 props_gen 生成 Recce Ul+ Vue + React + Android + iOS+HarmonyOs 等各种属性的操作代码。
2. **Rust（Wasm3）**：扩展 [wit-bindgen](https://github.com/bytecodealliance/wit-bindgen) 支持 Wasm3。
3. **QuickJS**：借助 Rust 宏封装一些本地函数（UI 操作接口）+ 自定义的二进制读写实现。
4. **业务方法调用 & 平台抽象层与 Platform 交互**：使用 [mako](https://www.makotemplates.org/) 完成接口调用和文档生成。

## 5 总结和展望

![](https://p0.meituan.net/meituantechblog/ee2be7ad06f96a2d9592d471301cb8a7567149.png)

最终我们获得了一个如上图的高性能、安全的动态化容器，可以以 Wasm 的方式支持原生级别的性能，也可以将 JavaScript 的前端工程的性能提升一截。

从某个角度看，像是我们把 RN 用 Rust 重写了，添加了 Wasm 解释器的支持。但用熟悉 WebView 架构的视角看，也可以看作是一个 WebEngine Lite，只是试图绘制暂时用的系统 UI。

文章最后做一下回望和展望。

**回望**：我们所做的所有架构和优化工作都可以概括为，区分本质复杂度和偶然复杂度，恰当的回应本质复杂度，降低偶然复杂度。

动态化容器的本质复杂度是什么？最主要的一条脉络是，渲染管线，以前端研发的编码逻辑和数据为输入，在管线中变为组件树 -> 虚拟文档树 -> 文档树 -> 视图树 / 样式树 -> 图层树 -> 呈现树，最终绘制到屏幕上为用户所眼见视图为输出。至于用什么 DSL、编程语言、解释器、编码方式等等其实是偶然复杂度。

Recce 的选型和搭建过程，实际上是围绕渲染管线进行优化，比如精简流程去掉了 VDOM 等环节，比如简化运行时、选用执行效率更高的解释器和编码方式等，再比如削峰填谷、消除瓶颈以提升渲染管线整体效率等。而这些工作都是为了降低容器本身的计算开销，因为动态化容器相对业务而言也是**偶然复杂度**。将终端有限的软硬件计算资源更多的留给**业务本质复杂度**是容器迭代的正确方向。

**展望**：目前 Recce 还在逐步完善和落地推广阶段，可以做的事情有很多：

* **改善开发体验**：比如引入 LLM 来降低 Rust 的学习门槛和开发成本，比如完善调试 & 脚手架工具链等等。
* **进一步优化性能**：比如以 Rust 原生方式运行以获得超过 Android 原生的性能表现；比如利用 Wasm 解释器线性内存特性，可以在 CI 上完成大部分的预计算，进一步提升加载性能表现；
* **自研渲染层**：这样一是能进一步提高性能，二也能降低多端维护成本，三是把样式能力集对齐到 WebView 可以实现和 H5、小程序的同构。当然这样其实就是 一个完整的 WebEngine Lite 了。

## 6 Q & A

**Q**：Recce 的性能如何？可以把这个问题更具象化一些吗？

**A**：目前从我们已经实践的范围中，在我们业务场景中能够找到最低端的 POS 设备上面，Recce UI 是可以和 Flutter 的性能表现媲美，而且我们是在动态解释运行，而 Flutter 是原生运行。也就是实现了原生级别的性能表现。

**Q**：以后 JS 没用了吗？

**A**：JS 有用的，但这个问题分两个层面回答。第一层，Recce 是支持这个 JS 运行时和相应生态的。比较极端的场景，比如说 POS 机，下沉市场的低端机，或者说对于性能要求很高的，比如说像 App 的首页冷启动，或者说像这个支付收银台等等这种场景下，优化性能的收益很大，那么就可以考虑用 Recce-rs 这个方案。如果不是这么极端的一般场景，我们用这个 Recce-js 的方案也能获得一个低成本，获得一个性能优化。性能优化是没有止境的，根据业务场景的需要去选择，Recce 提供了更多且更好的选择。

第二层，移动端开发从一开始就有原生开发和 H5/JS 开发（PhoneGap 发布于 2009 年），但 JS 成为主流，始于 2015 年，Google 把 V8 适配到了 Android 上。这里就不是 JS 行不行，而是 V8 很行。 终端硬件的计算资源始终是有限的，V8 通过解释器层面 JIT/AOT 编译技术 大幅提升了 JS 的运行效率，使得 JS 铺开成为可能。但近几年 JS 引擎不再有大幅度迭代，手机硬件算力的升级速度也明显放缓，这就导致了终端上 软硬件计算容量的提升速度跟不上业务复杂度的提升速度。这才是当下 JS 技术栈面临的问题，也是为什么有如此多 JS 框架在卷性能的原因。

当然大家不用特别悲观，JS 和 Web 始终是互联网最重要的基础设施，事物是呈现螺旋发展趋势的（当然有人负责发展，有人负责螺旋），随着周期演变，新的软硬件技术升级又会推动 JavaScript 往前发展。比如如果一个使用 TypeScript/JavaScript 的高性能解释器出来，那么能够使现在的 JavaScript 工程性能大幅度提升，毕竟前端线上代码资产 90% 是以 JavaScript 形式存在的。

**Q**：为什么叫 Recce ？

**A**：Recce/ˈrɛkiː/ 名字取自海豹部队的一把枪。选择这个名字的初衷是因为在 Recce-rs 选型的时候，目标是接近原生的性能表现、还要动态化，那么肯定要舍弃一部分开发体验的，切换 Rust 语言上会对研发同学增加学习成本、抬高门槛。因为预判到这一点，所以我们希望使用 Recce 的同学始终记得是经过了更多的训练的精英，要克服各种困难去完成高价值的任务。凡事有利必有弊，有用比有费，对于需要使用 Recce-rs 优化的场景 学习 Rust 就不是最难的技术问题。我们在为高价值场景提供更好的选择的同时，也将部分优化能力通过 Recce-js 反哺到一般业务场景上。不同的场景不同的成本结构，没有最好，只有合适的方案。

**Q**：Recce 为什么要追求原生级别的性能？

**A**：主要有三点原因。

**一、前端提升性能体验可以提升用户体验和业务获客效率**

前端部署和面客是重叠的过程，前端部署成功率影响业务面客。部署成功率低意味着，客户遇到白屏或不愿意等待最终放弃。提升性能可以提升前端部署成功率，进而可以提升用户体验和业务获客效率。

部署：代码离开开发环境，到用户终端设备运行前的这段环节为部署。

**二、追求原生级别性能的动态化容器是公司业务的发展需要**

美团业务的首要特点是低毛利，低毛利意味着业务发展需要做大规模，提升 UE，提升复购。

* 做大规模，意味着要争取广大下沉市场。那么在性能体验上就需要至少 Meet 友商，在下沉市场表现最好的应用（微信、拼多多）的主要功能都是原生实现的。争取下沉市场扩大规模在前端的命题意味着提供原生级别的性能体验，在下沉市场这可能不再是体验好坏而是能否使用的问题。
* 提升 UE，意味着必须要考虑研发人效，前端提研发人效就必须考虑跨平台同构，因此需要容器化，将多端开发降为一端开发。
* 提升复购，复购意味着多业态混合经营，那么在包大小约束下就必须要让大部分业务动态化。

综上，公司业务发展的需要决定了美团需要原生级别性能的动态化容器。

**三、部署是前端工程领域的核心问题，容器是部署问题的主要答案**

把时间拨回到 2010 年，彼时移动端开发方兴未艾，主要的技术栈只有 Native 和 H5（PhoneGap 为代表），其中 Native 性能表现好但不跨端、H5 迭代效率高但性能体验差。随着时间推移，Native 方向为了解决跨端研发成本和部署效率，发展出了 ReactNative、Flutter 等等方案，H5 方向为了改善性能，发展出了离线化、SSR/ESR、解释器优化等等。

可以说两个方向是相向而行，其实这是一个问题的两个面。究其根本在于前端代码运行在不受我们控制且计算资源有限的用户设备上，不同于后端的主要问题是高并发，前端的主要问题是怎样把代码低成本跨过物权边界送到大规模且不同的用户的设备上并高效运行起来。

回顾过去，性能表现好原生要做动态化降低部署成本，部署成本低的 H5 要优化性能提升用户体验。换句话说，前端工程领域的核心问题是部署成本和用户体验的平衡。比如包大小就是原生开发部署成本高而非常困扰客户端开发的一个典型例子。

## 注释

* [1] 逻辑解释器：在 iOS 中 Apple 不允许 JIT，只可以解释执行。
* [2] [WasmEdge](https://github.com/WasmEdge/WasmEdge)：亚马逊用做云原生的 Wasm 解释器。
* [3] C#：黑神话悟空就是用魔改 USharp 跑的游戏逻辑。
* [4] 不支持 JIT ：Apple 不允许在 iOS 上 JIT。
* [5] [C、C++、Rust、Go 这四种](https://github.com/appcypher/awesome-wasm-langs?tab=readme-ov-file#typescript)
* [6] blink：chromium 的布局渲染器。
