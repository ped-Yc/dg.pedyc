---
title: 30-使用 “黑魔法” 优雅的修改第三方依赖包
uid: 
author: 
description: 
date-created: 2024-08-16 23:03
date-modified: 2024-08-19 18:48
type: 
aliases: []
status: 
tags: []
---

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/412753695)

> 背景 Vue 项目中使用的 element-ui，由于弹窗里表单项太多，一些表单项会在可视范围之外。校验表单时，如果未通过校验的表单项在可视范围外，用户感知不强。所以需要在表单校验未通过时滚动到第一个未通过校验的表单…

![[ddd9aa0a367f45b6f1705d862dc6c0cd_MD5.jpg]]

**背景**
------

Vue 项目中使用的 element-ui，由于弹窗里表单项太多，一些表单项会在可视范围之外。校验表单时，如果未通过校验的表单项在可视范围外，用户感知不强。所以需要在表单校验未通过时滚动到第一个未通过校验的表单项那里，翻看 element-ui 文档，发现未提供该 API。

起初想到的方案有两种：

1. 在业务中封装函数，表单校验失败时调用该函数，根据表单校验失败的 className，获取第一个校验失败的 dom 元素，滚动到指定的 dom 元素位置。但是如果页面存在多个 form 表单需要做区分，会增加我们的一个工作量，并且不够优雅。
2. 修改 element-ui 的源码，增加一个 API。但是在平台编译时如果重新执行 `npm install` 时代码会被覆盖，并且团队协作时也会遇到这个问题，团队开发中有诸多不便。

后面经过一顿搜索后，发现一个 " 黑魔法 " 的解决方案。并且该方案上手简单、便携、且一劳永逸。

**黑魔法之 patch-package**
----------------------

![[42927381171126a4392c66cc7ef5b4ad_MD5.jpg]]

先看看官方是怎么介绍的

> `patch-package` lets app authors instantly make and keep fixes to npm dependencies. It's a vital band-aid for those of us living on the bleeding edge.
> Patches created by `patch-package` are automatically and gracefully applied when you use `npm`(>=5) or `yarn`.
> No more waiting around for pull requests to be merged and published. No more forking repos just to fix that one tiny thing preventing your app from working.

总而言之，`patch-package` 给开发者提供了通过打 " 补丁 " 的方式，使得重新安装依赖包时能够保留之前对第三方依赖包的修改的一种解决方案。

**patch-package 的应用场景**
-----------------------

想想我们在使用第三方依赖包时如果遇到了 bug，通常解决的方式都是绕过这个问题，使用其他方式解决，较为麻烦。或者给作者提个 issue 或者 PR，然后等待作者的修复。等待的时间不可控，如果你不想天天被产品、测试后面追着，是不是就可以借助 patch-package 自己动手去修复该 bug，感觉是不是很棒。并且还可以在第三方依赖包上，根据业务需求扩展能力。

Tip：最好还是扩展一些通用性比较高的能力，如果是比较通用且该能力大多数开发者都有这种诉求的话可以给第三方依赖包提个 PR。参与开源项目是不是简单了起来了～（不要在魔改的路上越走越远！！！）

**patch-package 的使用**
---------------------

## **Step1：安装**

**使用 npm 安装**

```Javascript
npm i patch-package


```

**使用 yarn 安装**

```Javascript
yarn add patch-package postinstall-postinstall


```

为什么要使用 yarn 安装需要多安装 `postinstall-postinstall` 这个依赖，有兴趣可以看官方解释。**[Why use postinstall-postinstall](https://link.zhihu.com/?target=https%3A//github.com/ds300/patch-package%23why-use-postinstall-postinstall-with-yarn)**

## **Step2：修改 package.json 文件**

package.json 的 scripts 中声明了一系列的 npm 脚本命令，如下：（参考资料：[http://caibaojian.com/npm/misc/scripts.html](https://link.zhihu.com/?target=http%3A//caibaojian.com/npm/misc/scripts.html)）

* prepublish: 在包发布之前运行，也会在 npm install 安装到本地时运行
* publish,postpublish: 包被发布之后运行
* preinstall: 包被安装前运行
* install,postinstall: 包被安装后运行
* preuninstall,uninstall: 包被卸载前运行
* postuninstall: 包被卸载后运行
* preversion: bump 包版本前运行
* postversion: bump 包版本后运行
* pretest,test,posttest: 通过 npm test 命令运行
* prestop,stop,poststop: 通过 npm stop 命令运行
* prestart,start,poststart: 通过 npm start 命令运行
* prerestart,restart,postrestart: 通过 npm restart 运行

可以看到依赖包在安装完之后会执行 postinstall 命令

所以我们在 package.json 的 scripts 里面增加：`"postinstall": "patch-package"`

```Javascript
"scripts": {
    ***,
+   "postinstall": "patch-package"
}


```

## **Step3：修改依赖包源码**

以 element-ui 为例：

![[c0664e7c02a41b435920c1f78b9fa931_MD5.jpg]]

我们在 `element-ui` 的 `Button` 组件上加一个类名 `button` 看看

![[d390617bf68df762d64122405c9db8dd_MD5.png]]

通过控制台查看我们的修改已经生效

## **Step4：生成补丁**

```Javascript
yarn patch-package package-name(修改的包名)
或者
npx patch-package package-name（npm版本 > 5.2）


```

这里我们执行 `npx patch-package element-ui` 命令看看

```Javascript
feiyu@feiyudeMacBook-Pro demo % npx patch-package element-ui
patch-package 6.4.7
patch-package: you have both yarn.lock and package-lock.json
Defaulting to using npm
You can override this setting by passing --use-yarn or deleting
package-lock.json if you don't need it

• Creating temporary folder
• Installing element-ui@2.15.6 with npm
• Diffing your files with clean files
✔ Created file patches/element-ui+2.15.6.patch

  element-ui is on GitHub! To draft an issue based on your patch run

    npx patch-package element-ui --create-issue


```

可以看到 `patch-package` 已经为我们创建了一个补丁。

默认会在我们的根目录下创建一个 patches 文件夹。在 patches 文件夹下会创建依赖包名 + 版本号. patch 的文件，文件描述了我们修改了什么，第几行，有点像 git 的提交记录。

![[7aab811e92901f5828a200104a1532ce_MD5.jpg]]

## **Step5：测试补丁是否有效**

* 手动删除 node_modules 文件夹，重新执行 `npm install` 安装依赖包。可以看到在依赖包安装结束后执行了 `patch-package` 命令，之前生成的补丁被应用了。

    > patch-package
    patch-package 6.4.7
    Applying patches…
    element-ui@2.15.6 ✔

* 查看 node-modules 中之前修改的 element-ui 修改的地方，查看之前修改的代码是否还存在。如果之前修改的代码还存在，说明补丁文件已经生效了，如果不存在，排查下是否哪个步骤出现了问题。

**最后将 patches 文件夹推送到远端仓库，日后无论是谁拉取代码，安装依赖，我们之前修改的部分都会生效的**

**注意事项**
--------

1. patch 是锁定版本号的，如果升级了版本，patch 内容将会失效，最好在 package.json 能够锁定版本号。
2. 魔改的同时，也局限了升级的能力，尽量还是去提 issue 和 PR。

**最后**
------

`patch-package` 还提供了一些额外的参数，有兴趣的话可以查看官方文档。

**参考资料**
--------

patch-package - 官方：[https://github.com/ds300/patch-package](https://link.zhihu.com/?target=https%3A//github.com/ds300/patch-package)

npm-scripts 文档：[http://caibaojian.com/npm/misc/scripts.html](https://link.zhihu.com/?target=http%3A//caibaojian.com/npm/misc/scripts.html)

Why use postinstall-postinstall：[https://github.com/ds300/patch-package#why-use-postinstall-postinstall-with-yarn](https://link.zhihu.com/?target=https%3A//github.com/ds300/patch-package%23why-use-postinstall-postinstall-with-yarn)

* END -
